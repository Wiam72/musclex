

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Processes &mdash; MuscleX  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> MuscleX
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Muscle X</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Installation/index.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Application Suite</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">MuscleX</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>Processes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/AppSuite/QuadrantFolding/Quadrant-Folding-How-it-works.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p>When an image is selected, the program will immediately process the image automatically. The resulting image will be saved as [image_name].result.tif in the qf_results folder that is created as a subdirectory of the folder containing the selected file. The program will process an image by going through a series of processes in the order described below</p>
<div class="section" id="processes">
<span id="processes"></span><h1>Processes<a class="headerlink" href="#processes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="find-center">
<span id="find-center"></span><h2>1. <a class="reference external" href="https://github.com/biocatiit/musclex/wiki/Image-Processing-Functions#finding-center">Find Center</a><a class="headerlink" href="#find-center" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="calculate-rotation-angle">
<span id="calculate-rotation-angle"></span><h2>2. <a class="reference external" href="https://github.com/biocatiit/musclex/wiki/Image-Processing-Functions#calculate-rotation-angle">Calculate Rotation Angle</a><a class="headerlink" href="#calculate-rotation-angle" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="calculate-average-quadrant">
<span id="calculate-average-quadrant"></span><h2>3. Calculate Average Quadrant<a class="headerlink" href="#calculate-average-quadrant" title="Permalink to this headline">¶</a></h2>
<p>To find the average fold, the image will be split into 4 quadrants, and each quadrant is flipped to be in the same orientation as below.</p>
<p>[[/images/QF/split_folds.png]]</p>
<p>After all quadrants are flipped, a new image will be generated by averaging each pixel from all quadrants. The mask threshold will be used to determine if that pixel will be included in averaging process. In this case, the mask threshold is 0. That means if the pixel intensity is less than 0, the program will ignore that pixel.  Finally, the result image will look like the image on the right. The full 2D pattern can then be regenerated by rotations of this image.</p>
<p>[[/images/QF/avg_fold2.png]]</p>
</div>
<div class="section" id="calculate-r-min-and-r-max">
<span id="calculate-r-min-and-r-max"></span><h2>4. Calculate R-min and R-max<a class="headerlink" href="#calculate-r-min-and-r-max" title="Permalink to this headline">¶</a></h2>
<p>For the background subtraction algorithms to work, it is necessary to define a [minimum radius R-min[(https://github.com/biocatiit/musclex/wiki/Image-Processing-Functions#calculate-r-min) and a maximum radius R-max to define the region that is assumed to contain real data. To find R-max, the radial histogram will first be re-computed  from the average folded image. R-max (blue line) is initially chosen to be  simply 60% of the diagonal of the image. These two values are intended as  just approximate starting points, that users can change manually.</p>
<p>[[/images/QF/rmin.png]]</p>
</div>
<div class="section" id="apply-background-subtraction">
<span id="apply-background-subtraction"></span><h2>5. Apply Background Subtraction<a class="headerlink" href="#apply-background-subtraction" title="Permalink to this headline">¶</a></h2>
<p>Fiber diffraction patterns from muscle have a substantial diffuse background arising from non-crystalline parts of the muscle that do not diffract coherently including membranes and mitochondria as well as diffuse scattering from the myosin heads. Intact cardiac muscle, in particular has a very strong background. This background pattern has a complex structure making it hard to model and effectively remove.  Various algorithms exist that attempt to remove the background. No one technique so far can effectively remove background in all parts of the image without over subtraction in some parts of the pattern but some techniques work better than others depending on the muscle and specific preparation. Quadrant folding implements several different algorithms  that can be used individually or in combination that can be used to background subtracted images for display or subsequent analysis.</p>
<p>Generally speaking, the “White Top-Hat” algorithm works well at large radii from the center and some other algorithm will work better than others, depending on the type of muscle generating the X-ray pattern,  at low radii. Two images will be produced from this process. The first image will be created using one of several  background subtraction approaches, and the second image will be created using the White-top-hat approach. These 2 images will be merged as described below. At present, there are 4 options for background subtraction in the first (low radius) image, Circularly symmetric, 2D Convex hull, and White-top-hat.</p>
<!---
#### 5.1 Angular Background Subtraction
[[/images/QF/angular.png]]<p>The necessary parameters for this scheme for background subtraction are the pixel range in percentages, and the angular bin size for integration in degrees. In this method, the program will:</p>
<ol class="simple">
<li>Obtain the 2D azimuthal integration from the average folded image. The x-axis represents radius, and y-axis represents angle. In this case, we need to do this integration for only one quadrant, so the angle range is from 0 to 90 °.</li>
<li>obtain the estimated background line for each bin. For example, if the degree bin size is 30. There will be 3 background estimates lines for each of the degree ranges 0-30, 30-60, and 60-90. Each background estimate line is produced by going to  each radial position in the angular  bin range, sort all pixels at that radius by intensities, and the background value is chosen as the mean value of intensities between specified pixel ranges from the minimum value to the maximum value. The background  value for each radius is used to generate a 1d background estimate for the chosen angular bin range. Each line will have a 1d convex hull applied to define a surface and the pchip algorithm is used to interpolate between points in the convex hull in order to generate a smooth curve.</li>
<li>a two D background image is formed from the individual lines by assuming the same profile throughout the angular bin range that generated it. This 2D image can then be subtracted from the original image to generate a background-subtracted image</li>
</ol>
<p>[[/images/QF/angular_img.png]]
–&gt;</p>
<div class="section" id="circularly-symmetric-background-subtraction">
<span id="circularly-symmetric-background-subtraction"></span><h3>5.1 Circularly symmetric Background Subtraction<a class="headerlink" href="#circularly-symmetric-background-subtraction" title="Permalink to this headline">¶</a></h3>
<p>[[/images/QF/csym_set.png]]</p>
<p>The necessary parameters for this scheme for background subtraction are the pixel range in percentages, the radius bin size in pixels, smooth parameter for spline. In this method, the program will</p>
<ol class="simple">
<li>Go to each radius bin, sort all pixel in the bin, and calculate background value by averaging intensity of pixels in specified pixel range</li>
<li>After the a background value is determined for each radius bin,  these values are combined by fitting a spline curve with specified smooth and tension parameters</li>
<li>A 2D background is generated by spreading the spline curve through 360 degrees. This 2D image can then be subtracted from the original image to generate a background-subtracted image</li>
</ol>
<p>This method is from <a class="reference external" href="http://www.diamond.ac.uk/Beamlines/Soft-Condensed-Matter/small-angle/SAXS-Software/CCP13/FibreFix/FibreFix.html">CCP13 FibreFix</a> and their fortran codes are available on <a class="reference external" href="https://github.com/scattering-central/CCP13">GitHub</a></p>
</div>
<div class="section" id="d-convex-hull-background-subtraction">
<span id="d-convex-hull-background-subtraction"></span><h3>5.2 2D Convex hull Background Subtraction<a class="headerlink" href="#d-convex-hull-background-subtraction" title="Permalink to this headline">¶</a></h3>
<p>[[/images/QF/2dcon_set.png]]</p>
<p>The necessary parameters for this kind of background subtraction are again R-max and R-min. Initial values for these parameters are provided by the program. Users can change these parameters if necessary.
The convex hull identifies the closest surface that contains all the points along the smoothly decaying background.  A 1D convex hull can be generated using the “shrink wrap” algorithm that follows the surface generating a series of of lowest points along the surface.  The 2D convex hull surface is created by generating a 1D convex hull background subtraction to the radially integrated intensity over a 0.5 angle bin for each bin in the 90 degree summed quadrant using R-min and R-max as start and end points for calculating the 1D convex hull. Prior to calculating the convex hull, this intensity trace is smoothed to reduce the effect of noise. To create a background image, the pchip algorithm is used to interpolate between points in each 1D convex hulls. The pchip algorithm will be used again to interpolate a surface joining the points on the 1D convex hulls to create a 3D background image. Then, the program will subtract the background image from the original image.</p>
<p>[[/images/QF/2dconvex_img.png]]</p>
</div>
<div class="section" id="roving-window-background-subtraction">
<span id="roving-window-background-subtraction"></span><h3>5.3 Roving Window Background Subtraction<a class="headerlink" href="#roving-window-background-subtraction" title="Permalink to this headline">¶</a></h3>
<p>[[/images/QF/roving.png]]</p>
<p>The necessary parameters for this kind of background subtraction are R-max, R-max, window size, window separation, pixel range, smooth and tension factors. The roving window background subtraction method of Paul Langan estimates the background by moving a window (of size input by the user) across the collected data. The pixel values within this window are sorted and those in the user-selected range are taken as background (except pixel values lying outside the pattern extents or specified by the user as values to discard). The average pixel value within this range is then assigned to be the estimated background at the centre of the window. Fiinally, a smoothing spline under tension is fitted to fill in the gaps between window centres. (From <a class="reference external" href="http://www.diamond.ac.uk/Beamlines/Soft-Condensed-Matter/small-angle/SAXS-Software/CCP13/FibreFix/FibreFix.html">FibreFix Document</a>)</p>
</div>
<div class="section" id="white-top-hat-background-subtraction">
<span id="white-top-hat-background-subtraction"></span><h3>5.4 White-top-hat Background Subtraction<a class="headerlink" href="#white-top-hat-background-subtraction" title="Permalink to this headline">¶</a></h3>
<p>[[/images/QF/tophat_set.png]]</p>
<p>The white top-hat transform is an operation that extracts small elements and details from given images. The white top-hat transform of f is given by Tw(f)= f – f°b where ° denotes the morphological <a class="reference external" href="https://en.wikipedia.org/wiki/Opening_%28morphology%29">opening operation</a> by a structural element b which we will call a kernel. This will retain features that are “smaller” than the structuring element (i.e., places where the structuring element does not fit in), and are brighter than their surroundings. So it is somewhat similar to the “rolling ball” background subtraction algorithm in ImageJ but more general. The only parameter that needs to be specified for this kind of background subtraction is the size of the applied kernel. The kernel will be created by using the <a class="reference external" href="http://scikit-image.org/docs/dev/api/skimage.morphology.html#skimage.morphology.disk">disk</a> function from scikit-image, and applied to original image by using the <a class="reference external" href="http://scikit-image.org/docs/dev/api/skimage.morphology.html#skimage.morphology.white_tophat">white_tophat</a> function.</p>
<p>[[/images/QF/tophat_img.png]]</p>
</div>
<div class="section" id="smoothed-background-subtraction">
<span id="smoothed-background-subtraction"></span><h3>5.5 Smoothed Background Subtraction<a class="headerlink" href="#smoothed-background-subtraction" title="Permalink to this headline">¶</a></h3>
<p>The necessary parameters are R-min, R-max, number of cycles, and filter type. This method of background subtraction is based on that of M.I. Ivanova and L. Makowski (Acta Cryst. (1998) A54, 626-631). For more information please see <a class="reference external" href="http://www.diamond.ac.uk/Beamlines/Soft-Condensed-Matter/small-angle/SAXS-Software/CCP13/FibreFix/FibreFix.html">CCP13 FibreFix</a></p>
<div class="section" id="gaussian">
<span id="gaussian"></span><h4>5.5.1 Gaussian<a class="headerlink" href="#gaussian" title="Permalink to this headline">¶</a></h4>
<p>[[/images/QF/smooth_g.png]]</p>
<p>This filter requires FWHM parameter</p>
</div>
<div class="section" id="boxcar">
<span id="boxcar"></span><h4>5.5.1 Boxcar<a class="headerlink" href="#boxcar" title="Permalink to this headline">¶</a></h4>
<p>[[/images/QF/smooth_b.png]]</p>
<p>This filter requires Box car size parameter</p>
</div>
</div>
</div>
<div class="section" id="merge-images">
<span id="merge-images"></span><h2>6. Merge Images<a class="headerlink" href="#merge-images" title="Permalink to this headline">¶</a></h2>
<p>If two background images are generated, one at high radius from the center, one at low, they are merged together by defining a “merge gradient”.  The merge radius (R-max) is the position at which the two background images are merged together while the “merge gradient” is a smoothness parameter to make the transition between the two images smooth.</p>
<p>[[/images/QF/merge.png]]</p>
<p>Merge gradient is a parameter k for [[/images/QF/gradient.png]] while r is merge radius. Therefore, if the merge border will be smoother when k &lt; 1. If k &gt; 1, the merge border will be more pronounced.</p>
</div>
<div class="section" id="generate-result-image">
<span id="generate-result-image"></span><h2>7. Generate Result Image<a class="headerlink" href="#generate-result-image" title="Permalink to this headline">¶</a></h2>
<p>To generate a result image, the program will just copy the background subtracted average folded image and flip them to correct their orientation for all 4 quadrants, and then combine them together.</p>
<p>[[/images/QF/result.png]]</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, BioCAT.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>